Timer unit: 1e-06 s

Total time: 0.291056 s
File: ./scripts/convolution/conv_3d_demo_profiling.py
Function: quadric_proj at line 10

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    10                                           @profile
    11                                           def quadric_proj(quadric: np.ndarray, idx: int) -> np.ndarray:
    12                                               """projects along one axis of the quadric"""
    13                                           
    14                                               # delete if orthogonal
    15     26163      19119.0      0.7      6.6      if np.abs(qii := quadric[idx, idx]) < 1e-8:
    16                                                   mask = np.arange(quadric.shape[0]) != idx
    17                                                   return quadric[np.ix_(mask, mask)]
    18                                           
    19                                               # row/column along which to perform the orthogonal projection
    20                                               # symmetrise if not symmetric, normalise to indexed component
    21     26163      47871.0      1.8     16.4      vec = 0.5 * (quadric[idx, :] + quadric[:, idx]) / np.sqrt(qii)
    22     26163      56433.0      2.2     19.4      ortho_proj = quadric - np.outer(vec, vec)  # projected quadric
    23                                           
    24                                               # return np.delete(np.delete(ortho_proj, idx, axis=0), idx, axis=1)
    25     26163      26922.0      1.0      9.2      mask = np.arange(ortho_proj.shape[0]) != idx
    26     26163     140711.0      5.4     48.3      return ortho_proj[np.ix_(mask, mask)]

Total time: 2.18397 s
File: ./scripts/convolution/conv_3d_demo_profiling.py
Function: convolution at line 185

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   185                                           @profile
   186                                           def convolution(reso_params):
   187      2907        355.0      0.1      0.0      if reso_params is None:
   188                                                   return np.nan
   189                                               # ----------------------------------------------------
   190                                               # calculate resolution matrix for all points
   191                                               # ----------------------------------------------------
   192      2907       2337.0      0.8      0.1      (qh, qk, ql), en, r0, mat = reso_params
   193      2907      47577.0     16.4      2.2      mat_hkl = quadric_proj(mat, 3)
   194                                               # ----------------------------------------------------
   195                                               # calculate the incoherent sigmas for all Q and E directions
   196                                               # ----------------------------------------------------
   197                                               # sigma_qs = [incoh_sigma_q(mat_hkl, i) for i in range(3)]
   198      2907     190393.0     65.5      8.7      sigma_qs = incoh_sigma_qs(mat_hkl)
   199      2907     110535.0     38.0      5.1      sigma_en_incoh = incoh_sigma_en(mat)
   200      2907        298.0      0.1      0.0      num_of_sigmas = 3
   201      2907       1058.0      0.4      0.0      min_en, max_en = en - num_of_sigmas * sigma_en_incoh, en + num_of_sigmas * sigma_en_incoh
   202      2907       3734.0      1.3      0.2      sigma_en_coh = coh_sigma(mat, 3)
   203      2907        441.0      0.2      0.0      en_rez = sigma_en_coh / 5
   204                                               # ----------------------------------------------------
   205                                               # Calculate elemental volume
   206                                               # ----------------------------------------------------
   207      2907      23161.0      8.0      1.1      eigenvalues = np.linalg.eigvalsh(mat_hkl)
   208      2907       3211.0      1.1      0.1      eval_inv_sqrt = 1 / np.sqrt(eigenvalues)
   209      2907       8855.0      3.0      0.4      elem_vols = np.prod(eval_inv_sqrt) * (2 * num_of_sigmas) ** 3
   210                                               # ----------------------------------------------------
   211                                               # First round, coarse grid
   212                                               # ----------------------------------------------------
   213      2907        536.0      0.2      0.0      pts = [10, 10, 10]
   214      2907     171722.0     59.1      7.9      (vqh, vqk, vql), idx = generate_pts(sigma_qs, num_of_sigmas, pts, mat_hkl)
   215                                               # vqh, vqk, vql = vqh[idx], vqk[idx], vql[idx]
   216                                               # ----------------------------------------------------
   217                                               # determine if sampled enough based on steps along energy
   218                                               # ----------------------------------------------------
   219      2907      22710.0      7.8      1.0      disp = model_disp(vqh + qh, vqk + qk, vql + ql)
   220      2907        598.0      0.2      0.0      num_bands, num_pts = disp.shape
   221                                           
   222                                               # Skip if all dispersion is outside the relevant energy window
   223      2907      15099.0      5.2      0.7      if np.max(disp) < min_en or np.min(disp) > max_en:
   224      1317        163.0      0.1      0.0          return 0.0
   225                                           
   226      1590       1523.0      1.0      0.1      vq = np.array((vqh, vqk, vql))  # shape: (3, num_pts)
   227      1590        586.0      0.4      0.0      vqe = np.empty((4, num_bands, num_pts))
   228      1590       1964.0      1.2      0.1      vqe[0:3] = vq[:, None, :]
   229      1590       1929.0      1.2      0.1      vqe[3] = disp - en
   230                                           
   231      1590     663014.0    417.0     30.4      weights = compute_weights(vqe, mat)  # shape: (num_bands, num_pts)
   232                                               # Skip if everything is outside the 5-sigma volume
   233      1590       8214.0      5.2      0.4      if np.min(weights) > 5**3:
   234        22          4.0      0.2      0.0          return 0.0
   235                                           
   236                                               # ----------------------------------------------------
   237                                               # determine Q steps based on energy steps
   238                                               # ----------------------------------------------------
   239      1568       4644.0      3.0      0.2      disp_arr = np.full(shape=(num_bands,) + idx.shape, fill_value=np.nan)
   240      1568      22546.0     14.4      1.0      disp_arr[(slice(None),) + np.nonzero(idx)] = disp
   241                                           
   242                                               # Compute max energy steps
   243      1568     162126.0    103.4      7.4      steps = [get_max_step(disp_arr, axis=i) for i in (1, 2, 3)]
   244                                           
   245      1568        167.0      0.1      0.0      max_step = 100  # limit the maximum in case the dispersion is too steep
   246      6272       2131.0      0.3      0.1      for i, (step, pt) in enumerate(zip(steps, pts)):
   247      4704        752.0      0.2      0.0          if step > en_rez:
   248      1568        305.0      0.2      0.0              factor = step / en_rez
   249      1568       7004.0      4.5      0.3              pts[i] = int(np.min((pt * factor, max_step)))
   250                                           
   251                                               # ----------------------------------------------------
   252                                               # Enough sampled. Calculate weight from resolution function
   253                                               # ----------------------------------------------------
   254      1568     221882.0    141.5     10.2      (vqh, vqk, vql), idx = generate_pts(sigma_qs, num_of_sigmas, pts, mat_hkl)
   255                                               # vqh, vqk, vql = vqh[idx], vqk[idx], vql[idx]
   256      1568      40852.0     26.1      1.9      disp = model_disp(vqh + qh, vqk + qk, vql + ql)
   257      1568        354.0      0.2      0.0      _, num_pts = disp.shape
   258                                           
   259                                               # ----------------------------------------------------
   260                                               # determine Q steps based on energy steps
   261                                               # ----------------------------------------------------
   262      1568       5980.0      3.8      0.3      disp_arr = np.full(shape=(num_bands,) + idx.shape, fill_value=np.nan)
   263      1568     129400.0     82.5      5.9      disp_arr[(slice(None),) + np.nonzero(idx)] = disp
   264                                           
   265                                               # Compute max energy steps
   266                                               # steps = [get_max_step(disp_arr, axis=i) for i in (1, 2, 3)]
   267      1568       8040.0      5.1      0.4      print(f"(Q1, Q2, Q3, E) = ({qh:.2f}, {qk:.2f}, {ql:.2f}, {en:.2f})")
   268                                               # print(f"number of points = {pts}")
   269                                               # print(f"steps in energy = ({steps[0]:.2f}, {steps[1]:.2f}, {steps[2]:.2f})")
   270                                           
   271      1568       6321.0      4.0      0.3      vq = np.array((vqh, vqk, vql))  # shape: (3, num_pts)
   272      1568       1082.0      0.7      0.0      vqe = np.empty((4, num_bands, num_pts))
   273      1568       6862.0      4.4      0.3      vqe[0:3] = vq[:, None, :]
   274      1568       7257.0      4.6      0.3      vqe[3] = disp - en
   275                                           
   276      1568     126361.0     80.6      5.8      weights = compute_weights(vqe, mat)  # shape: (num_bands, num_pts)
   277                                           
   278      1568      14985.0      9.6      0.7      idx_keep = np.any(weights < 5**3, axis=0)
   279      1568      27525.0     17.6      1.3      vq_filtered = vq[:, idx_keep]
   280      1568       1868.0      1.2      0.1      num_pts_keep = np.count_nonzero(idx_keep)
   281      1568       7701.0      4.9      0.4      percent_kep = num_pts_keep / np.prod(pts) * 100
   282      1568       6742.0      4.3      0.3      print(f"Number of pts inside the ellipsoid = {num_pts_keep}, percentage ={percent_kep:.3f}%")
   283      1568      45969.0     29.3      2.1      weights_filtered = np.exp(-weights[:, idx_keep] / 2)
   284      1568      11894.0      7.6      0.5      inten = model_inten(*vq_filtered)
   285                                           
   286                                               # normalization
   287      1568       7623.0      4.9      0.3      elem_vols /= np.prod(pts)
   288      1568      10504.0      6.7      0.5      det = np.linalg.det(mat)
   289      1568      12825.0      8.2      0.6      inten_sum = np.sum(inten * weights_filtered) * elem_vols
   290      1568       2254.0      1.4      0.1      return r0 * inten_sum * np.sqrt(det) / (2 * np.pi) ** 2

