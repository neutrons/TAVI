# -*- coding: utf-8 -*-
import os
from typing import Optional

import numpy as np


def _read_spice(file_name):
    """Reads an ascii generated by spice, and returns a header structure and a data table

    Args:
        file_name (str): a string containing the filename

    Returns:
        spice_data (np.ndarray): an array containing all columns/rows
        headers (dict): a dictionary containing information from the commented lines.
        col_headers (tuple): name of each collum in spice_data
        others (tuple): unrecogonized variables
    """
    with open(file_name, encoding="utf-8") as f:
        all_content = f.readlines()

    metadata = [line.strip() for line in all_content if "#" in line]
    index_col_name = metadata.index("# col_headers =")
    col_headers = tuple(metadata[index_col_name + 1].strip("#").split())
    metadata_list = metadata[:index_col_name]
    error_messages = metadata[index_col_name + 2 :]

    index_sum_count = [i for i, header in enumerate(metadata) if header.startswith("# Sum of Counts =")]
    # in case "Sum of Counts" doesn't exist
    # happens to the last scan after beam is down
    if len(index_sum_count) != 0:
        metadata_list += metadata[index_sum_count[0] :]
        error_messages = tuple(error_messages[: index_sum_count[0] - len(metadata)])

    headers = {}
    others = ()

    for metadata_entry in metadata_list:
        line = metadata_entry.strip("# ")

        if "completed" in line or "stopped" in line:  # last line
            parts = line.split(" ")
            headers["end_time"] = parts[3] + " " + parts[0] + " " + parts[1]
        # elif line[-1] == "=":  # empty line
        #     unused.append(line[:-2])  # remove  " ="
        elif "=" in line:  # useful line
            parts = line.split("=")
            key = parts[0].strip()
            val = "=".join(parts[1:])[1:]  # remove the fisrt space charactor
            headers[key] = val
        else:  # how did you get here?
            others += (line,)
    # others = tuple(others)

    spice_data = np.genfromtxt(file_name, comments="#")

    return spice_data, col_headers, headers, others, error_messages


def _read_spice_ub(ub_file_name):
    """Reads ub info from UBConf"""
    ubconf = {}
    with open(ub_file_name, encoding="utf-8") as f:
        all_content = f.readlines()

    for idx, line in enumerate(all_content):
        if line.strip() == "":
            continue  # skip if empty
        elif line.strip()[0] == "[":
            continue  # skiplines like "[xx]"

        ub_dict = {}
        key, val = line.strip().split("=")
        if key == "Mode":
            if all_content[idx - 1].strip() == "[UBMode]":
                ub_dict["UBMode"] = int(val)
            elif all_content[idx - 1].strip() == "[AngleMode]":
                ub_dict["AngleMode"] = int(val)
        else:
            if "," in line:  # vector
                ub_dict[key] = np.array([float(v) for v in val.strip('"').split(",")])
            else:  # float number
                ub_dict[key] = float(val)

        ubconf.update(ub_dict)

    return ubconf


def _format_spice_header(headers):

    formatted_headers = {}

    exp_str = ["scan_title", "users", "local_contact", "experiment"]
    for k, v in headers.items():
        if "," in v and k not in exp_str:  # vectors
            vec = np.array([float(v0) for v0 in v.split(",")])
            formatted_headers.update({k: vec})
        elif v.replace(".", "").isnumeric():  # numebrs only
            if v.isdigit():  # int
                formatted_headers.update({k: int(v)})
            else:  # float
                formatted_headers.update({k: float(v)})
        # separate COM/FWHM and its errorbar
        elif k == "Center of Mass":
            if v == "NaN+/-NaN":
                formatted_headers.update({"COM": np.nan, "COM_err": np.nan})
            else:
                com, e_com = v.split("+/-")
                formatted_headers.update({"COM": float(com), "COM_err": float(e_com)})
        elif k == "Full Width Half-Maximum":
            if v == "NaN+/-NaN":
                formatted_headers.update({"FWHM": np.nan, "FWHM_err": np.nan})
            else:
                fwhm, e_fwhm = v.split("+/-")
                formatted_headers.update({"FWHM": float(com), "FWHM_err": float(e_com)})
        else:  # other crap, keep as is
            formatted_headers.update({k: v})

    return formatted_headers


def spice_formatter(
    path_to_spice_folder: str,
    path_to_instrument_json: Optional[str] = None,
    path_to_sample_json: Optional[str] = None,
    verbose: bool = False,
) -> None:
    if path_to_spice_folder[-1] != "/":
        path_to_spice_folder += "/"

    scan_list = os.listdir(path_to_spice_folder + "Datafiles/")
    scan_list = [path_to_spice_folder + "Datafiles/" + scan for scan in scan_list if scan.endswith(".dat")]
    scan_list.sort()

    # get IPTS number and instrument string
    first_scan = scan_list[0]
    (_, _, headers, _, _) = _read_spice(first_scan)
    ipts = headers["proposal"]
    spice_file_name = first_scan.split("/")[-1]  # e.g. CG4C_exp0424_scan0001.dat
    instrument_str, exp_num, _ = spice_file_name.split("_")
